# 实现康威生命游戏

## 设计
在我们编码之前，我们有一些设计上的选择要考虑。

### 无限宇宙

生命的游戏是在无限的宇宙中进行的，但我们没有无限的记忆和计算能力。解决这个相当烦人的限制通常有三种方式：

1. 跟踪宇宙的哪个子集发生了有趣的事情，并根据需要扩展这个区域。在最坏的情况下，这种扩展是无限的，实现会越来越慢，最终耗尽内存。
2. 创建一个固定大小的宇宙，边缘的细胞比中间的细胞有更少的邻居。这种方法的缺点是，到达宇宙尽头的无限模式，如滑翔机，被扼杀了。
3. 创造一个固定大小、周期性的宇宙，其中边缘的细胞有环绕宇宙另一边的邻居。因为邻居环绕着宇宙的边缘，所以滑翔机可以永远不停地飞行。

我们将实施第三种选择。

### 设计 Rust 和 JavaScript 的接口

> ⚡ 这是一个最重要的概念，了解了可以忽略本教程！

JavaScript 的垃圾收集堆（在这里分配对象、数组和DOM节点）不同于 WebAssembly 的线性内存空间，在这里我们的 trust 值存在。WebAssembly 目前无法直接访问垃圾收集堆（截至2018年4月，这一点预计将随“接口类型”建议而改变）。另一方面，JavaScript 可以读写 WebAssembly 线性内存空间，但只能作为标量值（`u8`、`i32`、`f64`等）的`ArrayBuffer`。WebAssembly 函数还获取并返回标量值。这些是构成所有 WebAssembly 和 JavaScript 通信的构建块。

`wasm_bindgen` 定义了如何跨此边界处理复合结构的共同理解。
它包括封装的 Rust structures，将指针封装到 JavaScript 类中以获得可用性，或者从 Rust 索引到 JavaScript 对象表中。
`wasm_bindgen` 非常方便，但是它不需要考虑我们的数据表示，以及通过这个边界传递什么值和结构。相反，可以将它看作是实现所选接口设计的工具。

在设计 WebAssembly 和 JavaScript 之间的接口时，我们希望优化以下属性：

1. **最小化对WebAssembly线性内存的复制。** 不必要的拷贝会带来不必要的开销。
2. **最小化序列化和反序列化。**类似于副本，序列化和反序列化也会带来开销，而且还经常要求复制。如果我们能把不透明的操作传递数据结构 —— 与其在一边序列化，不如将其复制到WebAssembly线性内存中的某个已知位置，在另一边反序列化 —— 我们可以减少很多开销。`wasm_bindgen` 帮助我们定义和使用 JavaScript 对象或封装的 Rust structures，将指针封装到的不透明操作。

一般来说，一个好的 JavaScript↔WebAssembly 接口设计通常是将大型、长寿命的数据结构实现为驻留在 WebAssembly 线性内存中的 Rust 类型，并将其作为不透明操作开放给JavaScript。
JavaScript 调用导出的 WebAssembly 函数，这些函数接受这些不透明的操作，转换它们的数据，执行繁重的计算，查询数据，最终返回一个小的、可复制的结果。通过只返回较小的计算结果，我们可以避免在 JavaScript 垃圾收集堆和 WebAssembly 线性内存之间来回复制和/或序列化所有内容。
